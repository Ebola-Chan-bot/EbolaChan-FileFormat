#pragma once
#include<stdint.h>
#ifdef __cpp_lib_modules
import std;
#else
#include<vector>
#endif
/*埃博拉酱文件格式由一个个块组成。要向文件格式中存入数据，必须先分配块。可以自动分配空闲块，也可以手动指定固定的块索引。块索引保存在文件中，因此不会随程序结束而失效，下次读入时可以用同样的索引访问到同样的数据。一种典型的用法是将自动分配的块索引保存在手动指定的固定索引块中，实现块之间的动态链接。
提供两种读写数据的方式，称为句柄式和流式。句柄式允许你获取数据块的指针，以支持更广泛的C++操作而无需拷贝数据。流式则相对受限，读写时必须提供缓冲区并发生拷贝，但对于某些基础设施可能是更高效甚至唯一允许的方式。
不同于其它大多数文件格式提供的原生库操作，本格式的原生库操作不要求文件一定存在于磁盘上。你可以令文件完全存在于内存中、通过网络传输，甚至作为其它文件的一部分。你甚至可以将非平凡类型（例如标准库容器！），作为文件的基础资源，抑或是反过来将其保存在文件中，并且能够在创建它的程序结束后由另一个程序来读入（当然，这要求该非平凡类型没有重要的全局状态，且在两个程序中具有相同的定义）。
*/
namespace 埃博拉酱文件格式
{
	struct 句柄式分配器
	{
		std::pmr::vector<char>& 底层资源;
		//构造句柄式分配器，要求你提供一个pmr::vector<char>，文件的全部字节将存放在此向量中。
		constexpr 句柄式分配器(std::pmr::vector<char>& 底层资源) :底层资源(底层资源) {}
	};
	using 内存句柄 = uint64_t;
	//允许你将一个文件映射到内存中，分配指针访问存储块。本类所有方法可能抛出std::system_error
	struct 内存映射容器
	{
		//对象负责管理文件句柄，不需要用户关闭
		void* const 文件句柄;
		内存映射容器(const char* 文件路径);
		内存映射容器(const wchar_t* 文件路径);
		内存句柄 分配(uint64_t 字节数);
		void 重分配(内存句柄 句柄, uint64_t 字节数);
		//输入无效句柄将抛出std::out_of_range。此指针在对容器进行任何操作后都可能失效
		void* 取指针(内存句柄 句柄);
		//输入无效句柄将抛出std::out_of_range
		void 释放(内存句柄 句柄)const;
		~内存映射容器();
		内存映射容器(const 内存映射容器&) = delete;
		内存映射容器& operator=(const 内存映射容器&) = delete;
	protected:
		void* 映射句柄;
		void* 映射指针;
		uint64_t 文件大小;
	};
	//允许你在一个std::iostream容器中分配空间，例如std::fstream，或者任何其它实现std::iostream并允许使用seekp扩展的流式容器。
	struct 随机流式容器
	{
		std::iostream& 基础流;
		//容器只拥有基础流的引用，基础流的生命周期需要用户自行管理
		随机流式容器(std::iostream& 基础流);
		内存句柄 分配(uint64_t 字节数)const;
		void 重分配(内存句柄 句柄, uint64_t 字节数)const;
		void 读入(内存句柄 句柄, void* 缓冲区, uint64_t 字节数, uint64_t 偏移 = 0)const;
		void 写出(内存句柄 句柄, const void* 缓冲区, uint64_t 字节数, uint64_t 偏移 = 0)const;
		void 释放(内存句柄 句柄)const;
	};
}